#!/usr/bin/env bash

set -euo pipefail

# {{{ defaults

# work out if we're on a CI runner
CI=
if [[ -n ${GITHUB_SHA:-} ]]; then
  CI=1
fi

predicateType=https://github.com/0compute/nix-seed
registry=ghcr.io
result=./result
rekorUrl=https://rekor.sigstore.dev

# }}}

# {{{ getopt

usage() {
  cat <<EOF
Usage:
  publish IMAGE_NAME COMMIT_SHA
Options:
  --tag TAG            add an extra tag such as IMAGE_NAME:latest
  --registry REGISTRY
    registry to log into and use for pushing (default: $registry)
  --result RESULT      path to an existing docker load input (default: $result)
  --builder-identity ID
    explicit builder identity if it differs from context
  --predicate-type TYPE
    cosign predicate type for the attestation (default: $predicateType)
  --rekor-url URL       Rekor endpoint to log attestations (default: $rekorUrl)
Args:
  IMAGE_NAME  repository to push (e.g., ghcr.io/org/nix-seed)
  COMMIT_SHA  git commit SHA for verification
EOF
}

PARSED=$(
  getopt \
    --options '' \
    --long tag:,registry:,result:,predicate-type:,builder-identity:,rekor-url: \
    -- "$@"
) || {
  usage
  exit 1
}
eval set -- "$PARSED"

builderIdentity=
tags=()
while true; do
  case "$1" in
  --tag)
    tags+=("$2")
    shift 2
    ;;
  --registry)
    registry=$2
    shift 2
    ;;
  --result)
    result=$2
    shift 2
    ;;
  --predicate-type)
    predicateType=$2
    shift 2
    ;;
  --builder-identity)
    builderIdentity=$2
    shift 2
    ;;
  --rekor-url)
    rekorUrl=$2
    shift 2
    ;;
  --)
    shift
    break
    ;;
  *)
    usage
    exit 1
    ;;
  esac
done

if [[ $# -ne 2 ]]; then
  usage
  exit 1
fi

name=$1
commit=$2
image="$name:$commit"

# }}}

# {{{ sanity check

[[ -e $result ]] || {
  echo >&2 "result path '$result' does not exist"
  exit 1
}
[[ -n ${REGISTRY_USER:-} && -n ${REGISTRY_PASS:-} ]] || {
  echo >&2 "REGISTRY_USER and REGISTRY_PASS must be set"
  exit 1
}

# }}}

# {{{ load/tag/push

result=$(podman load --input "$result" | awk 'NR==1 {print $NF}')
[[ $result =~ :$commit$ ]] || {
  echo >&2 "commit mismatch $result != $commit"
  exit 1
}

podman login \
  --username "$REGISTRY_USER" \
  --password-stdin "$registry" \
  <<<"$REGISTRY_PASS"

# tag and push, for CI do the push in one go
tags+=(
  "$commit"
  "$(git describe --tags --always)"
)
for tag in "${tags[@]}"; do
  nametag="$name:$tag"
  podman tag "$result" "$nametag"
  [[ -n $CI ]] || podman push "$nametag"
done
[[ -z $CI ]] || podman push --all-tags "$name"

# }}}

# {{{ attest

predicate="./$commit.$system.json"

system=$(nix eval --raw ".#seed.system")

# identity, if not supplied tries a few env vars then falls back to user@host
if [[ -z $builderIdentity ]]; then
  for candidate in BUILDER_IDENTITY GITHUB_ACTOR; do
    value=${!candidate:-}
    if [[ -n $value ]]; then
      builderIdentity=$value
      break
    fi
  done
fi
if [[ -z ${builderIdentity} ]]; then
  builderIdentity=$(whoami)@$(hostname --fqdn)
fi

cat <<EOF >"$predicate"
{
  "schemaVersion": 1,
  "predicateType": "$predicateType",
  "timestamp": "$(date --utc +'%Y-%m-%dT%H:%M:%SZ')",
  "image": "$(podman inspect --format='{{index .RepoDigests 0}}' "$image")",
  "registry": "$registry",
  "commit": "$commit",
  "system": "$system",
  "narHash": "$(
  nix path-info --json --json-format 1 "$result" | jq --raw-output '.[].narHash'
)",
  "layerHashes": $(
  tar --extract --file "$result" --to-stdout manifest.json |
    jq --raw-output '.[0].Layers | map(split("/")[0]) | @json'
),
  "tags": $(
  printf '%s\n' "${tags[@]}" | jq --raw-input '.' | jq --slurp '.'
),
  "builder": {
    "identity": "$builderIdentity",
    "actor": "${GITHUB_ACTOR:-}",
    "repository": "${GITHUB_REPOSITORY:-}",
    "workflow": "${GITHUB_WORKFLOW:-}",
    "runId": "${GITHUB_RUN_ID:-}",
    "event": "${GITHUB_EVENT_NAME:-}",
    "ref": "${GITHUB_REF:-}"
  }
}
EOF

echo "wrote: $predicate"

cosign attest \
  --rekor-url "$rekorUrl" \
  --type "$predicateType" \
  --predicate "$predicate" \
  "$image"

cosign upload blob --files=$predicate "$image"

# }}}
